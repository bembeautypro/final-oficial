Aplique as seguintes ações no projeto, focadas em: (a) reduzir bundle inicial, (b) atualizar tooling, (c) corrigir vulnerabilidades, (d) melhorar TBT/INP e bfcache. Não alterar a lógica do player.

────────────────────────────────────────────────────────
1) TOOLING / VULNERABILIDADES
- Substituir dependências @esbuild-kit por tsx e atualizar scripts:
  • Remover @esbuild-kit/esm-loader e @esbuild-kit/core-utils das dependências (se existirem).
  • Adicionar "tsx" como devDependency.
  • Em "scripts" do package.json:
      "dev": "tsx watch src/index.ts",
      "start": "node dist/server/index.js"  // ajuste se tiver server
      "build": "vite build --config vite.config.deploy.ts"
- Executar:
  • npm audit fix
  • (Se ainda restarem vulnerabilidades relevantes em produção) npm audit fix --force

────────────────────────────────────────────────────────
2) VITE – SPLIT/OTIMIZAÇÃO DE BUNDLE
- Em vite.config.deploy.ts (ou vite.config.ts) garantir:
  import { defineConfig } from 'vite';
  export default defineConfig({
    build: {
      target: 'es2018',
      cssCodeSplit: true,
      sourcemap: false,
      rollupOptions: {
        treeshake: true,
        output: {
          manualChunks(id) {
            // separar libs conhecidas do vendor
            if (id.includes('node_modules')) {
              if (id.includes('react') || id.includes('react-dom')) return 'vendor-react';
              if (id.includes('framer') || id.includes('motion')) return 'vendor-motion';
              if (id.includes('lodash') || id.includes('date-fns') || id.includes('dayjs')) return 'vendor-utils';
              return 'vendor';
            }
            // splitar seções/rotas abaixo da dobra
            if (id.includes('/src/sections/')) return 'sections';
            return null;
          }
        }
      },
      minify: 'esbuild'
    }
  });

- No código, adiar JS que não é da dobra (garantir import dinâmico):
  window.addEventListener('load', async () => {
    const m = await import('./chunks/belowFold.js');
    m?.init?.();
  });

────────────────────────────────────────────────────────
3) EVENTOS PASSIVE / BFCACHE
- Antes de </body>, injetar (se não existir) para tornar scroll/touch passive por padrão:
  <script>
  (function(){
    const ORIG = EventTarget.prototype.addEventListener;
    EventTarget.prototype.addEventListener = function(t, l, o){
      const needsPassive = ['scroll','touchstart','touchmove','mousewheel'].includes(t);
      if (needsPassive) {
        if (!o || typeof o !== 'object') o = { passive: true };
        else if (o.passive === undefined) o.passive = true;
      }
      return ORIG.call(this, t, l, o);
    };
  })();
  </script>

- Remover listeners de 'unload' e 'beforeunload' se existirem.

────────────────────────────────────────────────────────
4) CSS – PURGE / CRÍTICO
- tailwind.config.{js,ts}:
  module.exports = { content: ["./index.html","./src/**/*.{ts,tsx,js,jsx}"], theme:{extend:{}}, plugins:[] }
- Injetar CSS crítico mínimo (header/hero ≤3KB) inline em <head> ANTES do CSS principal.
- Manter:
  <link rel="preload" href="/assets/index.css" as="style">
  <link rel="stylesheet" href="/assets/index.css">

────────────────────────────────────────────────────────
5) IMAGENS / FONTS
- Confirmar que toda imagem abaixo da dobra tem:
  • loading="lazy"
  • width/height ou style="aspect-ratio:W/H"
  • srcset + sizes coerentes
- Fontes:
  • Remover preloads e @font-face que apontem para arquivos inexistentes.
  • Se usar woff2 local, manter font-display: swap; caso contrário usar fallback system-ui.

────────────────────────────────────────────────────────
6) DICA OPERACIONAL (fora do código, mas importante)
- Na Vercel, manter “Build Cache” habilitado e evitar deploys com flag “sem cache”.
- Se usar “vercel --prod”, não passar flags que invalidem cache sem necessidade.

────────────────────────────────────────────────────────
7) VERIFICAÇÃO
- Rebuild/Deploy.
- Esperado:
  • index-*.js reduzido (parte movida para vendor-*.js e sections-*.js)
  • TBT/INP menores em mobile
  • Menos long tasks
  • Build na Vercel mais rápido quando cache habilitado